/* automatically generated by rust-bindgen 0.64.0 */

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vsl_host {
    _unused: [u8; 0],
}
#[doc = " The VSLHost object manages a connection point at the user-defined path and\n allows frames to be registered for client use."]
pub type VSLHost = vsl_host;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vsl_client {
    _unused: [u8; 0],
}
#[doc = " The VSLClient object manages a single connection to a VSLHost."]
pub type VSLClient = vsl_client;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vsl_frame {
    _unused: [u8; 0],
}
#[doc = " The VSLFrame object represents a single video frame from either the host\n or client perspective.  Certain API are only available to the host or client."]
pub type VSLFrame = vsl_frame;
#[doc = " Function pointer definition which will be called as part of\n @ref vsl_frame_unregister.  This is typically used to free resources\n associated with the frame on either client or host side."]
pub type vsl_frame_cleanup = ::std::option::Option<unsafe extern "C" fn(frame: *mut VSLFrame)>;
extern "C" {
    #[doc = " Returns the VideoStream Library version."]
    pub fn vsl_version() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn vsl_timestamp() -> i64;
}
extern "C" {
    #[doc = " Creates a host on the requested path.  If the path is unavailable because\n of permissions or already exists then NULL is returned and errno is set.\n\n @memberof VSLHost"]
    pub fn vsl_host_init(path: *const ::std::os::raw::c_char) -> *mut VSLHost;
}
extern "C" {
    #[doc = " Releases the host, disconnecting all clients and releasing any allocated\n memory.\n\n @memberof VSLHost"]
    pub fn vsl_host_release(host: *mut VSLHost);
}
extern "C" {
    #[doc = " Returns the bound path of the host.\n\n @memberof VSLHost"]
    pub fn vsl_host_path(host: *const VSLHost) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Polls the list of available connections in our pool.  If @param wait is >0\n then poll will timeout after @param wait milliseconds.  Note frames are only\n expired by the @ref vsl_host_process function so the @param wait parameter\n should be some value no greater than the desired expiration time.\n\n @memberof VSLHost"]
    pub fn vsl_host_poll(host: *mut VSLHost, wait: i64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Services the client socket."]
    pub fn vsl_host_service(
        host: *mut VSLHost,
        sock: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Process the host tasks by first expiring old frames and then servicing the\n first available connection in our pool.  This function should be called in a\n loop, generally blocked by @ref vsl_host_poll.\n\n @memberof VSLHost"]
    pub fn vsl_host_process(host: *mut VSLHost) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Request a copy of the sockets managed by the host.  There will always be at\n least one socket which is the connection socket which accepts new\n connections.  Up to n_sockets socket descriptors will be copied into the\n sockets buffer, if n_sockets is fewer than the number of available sockets\n errno will be set to ENOBUFS. The n_socket parameter, if provided, will be\n populated with a value of n_clients+1 which can be used to query required\n space for the sockets buffer.  It is suggested to provide a buffer which is\n larger than max_sockets to avoid race conditions where the number of sockets\n changes between calls to this function.\n\n Note that the array of sockets should be refreshed often as once the function\n returns they may be stale.  The API is implemented in such as way as to allow\n thread-safe operations where one thread may-be using the vsl sockets to send\n messages while another is polling for a read.\n\n @memberof VSLHost"]
    pub fn vsl_host_sockets(
        host: *mut VSLHost,
        n_sockets: usize,
        sockets: *mut ::std::os::raw::c_int,
        max_sockets: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Creates a client and connects to the host at the provided path.  If the\n connection cannot be made NULL is returned and errno is set.\n\n @memberof VSLClient"]
    pub fn vsl_client_init(
        path: *const ::std::os::raw::c_char,
        userptr: *mut ::std::os::raw::c_void,
        reconnect: bool,
    ) -> *mut VSLClient;
}
extern "C" {
    #[doc = " Releases the client, disconnecting from the host and releasing allocated\n memory.\n\n @memberof VSLClient"]
    pub fn vsl_client_release(client: *mut VSLClient);
}
extern "C" {
    #[doc = " Disconnects from the VSLHost and stops all reconnection attempts.  This should\n be called as part of closing down a VSL client session.  It is thread-safe\n unlike vsl_client_release which disposes of the client object.\n\n @memberof VSLClient\n @since 1.1"]
    pub fn vsl_client_disconnect(client: *mut VSLClient);
}
extern "C" {
    #[doc = " Returns the optional userptr associated with this client connection.\n\n @memberof VSLClient"]
    pub fn vsl_client_userptr(client: *mut VSLClient) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Returns the path on which the client has connected to the host.\n\n @memberof VSLClient"]
    pub fn vsl_client_path(client: *const VSLClient) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Sets the socket timeout for this client.\n\n @memberof VSLClient"]
    pub fn vsl_client_set_timeout(client: *mut VSLClient, timeout: f32);
}
extern "C" {
    #[doc = " Registers the video frame along with optional user pointer to any\n arbitrary data.  Typically it would be used for holding a reference to\n the host's view of the frame handle.\n\n @memberof VSLFrame"]
    pub fn vsl_frame_register(
        host: *mut VSLHost,
        serial: i64,
        handle: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        fourcc: u32,
        size: usize,
        offset: usize,
        expires: i64,
        duration: i64,
        pts: i64,
        dts: i64,
        cleanup: vsl_frame_cleanup,
        userptr: *mut ::std::os::raw::c_void,
    ) -> *mut VSLFrame;
}
extern "C" {
    #[doc = " Unregisters the frame, removing it from the host pool.\n\n @memberof VSLFrame"]
    pub fn vsl_frame_unregister(frame: *mut VSLFrame);
}
extern "C" {
    #[doc = " Returns the user pointer associated with this frame.\n\n @memberof VSLFrame"]
    pub fn vsl_frame_userptr(frame: *mut VSLFrame) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Associate userptr with this frame.\n\n @memberof VSLFrame"]
    pub fn vsl_frame_set_userptr(frame: *mut VSLFrame, userptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Waits for a frame to arrive and returns a new frame object.  Frames who's\n timestamp is less than @param until will be ignored.\n\n @memberof VSLFrame"]
    pub fn vsl_frame_wait(client: *mut VSLClient, until: i64) -> *mut VSLFrame;
}
extern "C" {
    #[doc = " Releases a client side frame and frees any allocated memory.  You should\n first unmap and unlock the video frame before releasing it.\n\n @memberof VSLFrame"]
    pub fn vsl_frame_release(frame: *mut VSLFrame);
}
extern "C" {
    #[doc = " Attempts to lock the video frame.\n\n @memberof VSLFrame"]
    pub fn vsl_frame_trylock(frame: *mut VSLFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Attempts to unlock the video frame.\n\n @memberof VSLFrame"]
    pub fn vsl_frame_unlock(frame: *mut VSLFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the serial frame count of the video frame.\n\n Note this frame serial tracks the count of frames registered on the host and\n does not necessarily equal the actual frame number from the camera.\n\n @memberof VSLFrame"]
    pub fn vsl_frame_serial(frame: *const VSLFrame) -> i64;
}
extern "C" {
    #[doc = " Returns the timestamp for this frame in nanoseconds.\n\n @memberof VSLFrame"]
    pub fn vsl_frame_timestamp(frame: *const VSLFrame) -> i64;
}
extern "C" {
    #[doc = " Returns the duration for this frame in nanoseconds.\n\n @memberof VSLFrame"]
    pub fn vsl_frame_duration(frame: *const VSLFrame) -> i64;
}
extern "C" {
    #[doc = " Returns the presentation timestamp for this frame in nanoseconds.\n\n @memberof VSLFrame"]
    pub fn vsl_frame_pts(frame: *const VSLFrame) -> i64;
}
extern "C" {
    #[doc = " Returns the decode timestamp for this frame in nanoseconds.\n\n @memberof VSLFrame"]
    pub fn vsl_frame_dts(frame: *const VSLFrame) -> i64;
}
extern "C" {
    #[doc = " Returns the epiration time for this frame in milliseconds.\n\n @memberof VSLFrame"]
    pub fn vsl_frame_expires(frame: *const VSLFrame) -> i64;
}
extern "C" {
    #[doc = " Returns the FOURCC code for the video frame.\n\n @memberof VSLFrame"]
    pub fn vsl_frame_fourcc(frame: *const VSLFrame) -> u32;
}
extern "C" {
    #[doc = " Returns the width in pixels of the video frame.\n\n @memberof VSLFrame"]
    pub fn vsl_frame_width(frame: *const VSLFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the height in pixels of the video frame.\n\n @memberof VSLFrame"]
    pub fn vsl_frame_height(frame: *const VSLFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the size in bytes of the video frame.\n\n @memberof VSLFrame"]
    pub fn vsl_frame_size(frame: *const VSLFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the file descriptor for this frame or -1 if none is associated.\n\n @memberof VSLFrame"]
    pub fn vsl_frame_handle(frame: *const VSLFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the physical address of the frame.  If the frame does not support\n DMA then MMAP_FAILED is returned.\n\n @memberof VSLFrame"]
    pub fn vsl_frame_paddr(frame: *const VSLFrame) -> isize;
}
extern "C" {
    #[doc = " Maps the frame into the process' memory space, optionally also sets the\n size of the frame if @param size is non-NULL.  Ensure the frame is\n unmapped when no longer needed using @ref nn_frame_munmap().\n\n Note that a frame must be locked for the duration of the mapping.\n\n @memberof VSLFrame"]
    pub fn vsl_frame_mmap(frame: *mut VSLFrame, size: *mut usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Maps the frame into the process' memory space, optionally also sets the\n size of the frame if @param size is non-NULL.\n\n @memberof VSLFrame"]
    pub fn vsl_frame_munmap(frame: *mut VSLFrame);
}
