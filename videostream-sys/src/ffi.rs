/* automatically generated by rust-bindgen 0.66.1 */

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vsl_host {
    _unused: [u8; 0],
}
#[doc = " The VSLHost object manages a connection point at the user-defined path and\n allows frames to be registered for client use."]
pub type VSLHost = vsl_host;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vsl_client {
    _unused: [u8; 0],
}
#[doc = " The VSLClient object manages a single connection to a VSLHost."]
pub type VSLClient = vsl_client;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vsl_frame {
    _unused: [u8; 0],
}
#[doc = " The VSLFrame object represents a single video frame from either the host\n or client perspective.  Certain API are only available to the host or client."]
pub type VSLFrame = vsl_frame;
#[doc = " The VSLRect structure represents a rectangle region of a frame and is used to\n define cropping regions for sub-frames."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vsl_rect {
    #[doc = " The left-most pixel offset for the rectangle."]
    pub x: ::std::os::raw::c_int,
    #[doc = " The top-most pixel offset for the rectangle."]
    pub y: ::std::os::raw::c_int,
    #[doc = " The width in pixels of the rectangle.  The end position is x+width."]
    pub width: ::std::os::raw::c_int,
    #[doc = " The height in pixels of the rectangle.  The end position is y+height."]
    pub height: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_vsl_rect() {
    const UNINIT: ::std::mem::MaybeUninit<vsl_rect> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vsl_rect>(),
        16usize,
        concat!("Size of: ", stringify!(vsl_rect))
    );
    assert_eq!(
        ::std::mem::align_of::<vsl_rect>(),
        4usize,
        concat!("Alignment of ", stringify!(vsl_rect))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vsl_rect),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vsl_rect),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vsl_rect),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(vsl_rect),
            "::",
            stringify!(height)
        )
    );
}
#[doc = " The VSLRect structure represents a rectangle region of a frame and is used to\n define cropping regions for sub-frames."]
pub type VSLRect = vsl_rect;
#[doc = " Function pointer definition which will be called as part of\n @ref vsl_frame_unregister.  This is typically used to free resources\n associated with the frame on either client or host side."]
pub type vsl_frame_cleanup = ::std::option::Option<unsafe extern "C" fn(frame: *mut VSLFrame)>;
extern "C" {
    #[doc = " Returns the VideoStream Library version."]
    pub fn vsl_version() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn vsl_timestamp() -> i64;
}
extern "C" {
    #[doc = " Creates a host on the requested path.  If the path is unavailable because\n of permissions or already exists then NULL is returned and errno is set.\n\n @memberof VSLHost"]
    pub fn vsl_host_init(path: *const ::std::os::raw::c_char) -> *mut VSLHost;
}
extern "C" {
    #[doc = " Releases the host, disconnecting all clients and releasing any allocated\n memory.\n\n @memberof VSLHost"]
    pub fn vsl_host_release(host: *mut VSLHost);
}
extern "C" {
    #[doc = " Returns the bound path of the host.\n\n @memberof VSLHost"]
    pub fn vsl_host_path(host: *const VSLHost) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Polls the list of available connections in our pool.  If @param wait is >0\n then poll will timeout after @param wait milliseconds.  Note frames are only\n expired by the @ref vsl_host_process function so the @param wait parameter\n should be some value no greater than the desired expiration time.\n\n @memberof VSLHost"]
    pub fn vsl_host_poll(host: *mut VSLHost, wait: i64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Services the client socket."]
    pub fn vsl_host_service(
        host: *mut VSLHost,
        sock: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Process the host tasks by first expiring old frames and then servicing the\n first available connection in our pool.  This function should be called in a\n loop, generally blocked by @ref vsl_host_poll.\n\n @memberof VSLHost"]
    pub fn vsl_host_process(host: *mut VSLHost) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Request a copy of the sockets managed by the host.  There will always be at\n least one socket which is the connection socket which accepts new\n connections.  Up to n_sockets socket descriptors will be copied into the\n sockets buffer, if n_sockets is fewer than the number of available sockets\n errno will be set to ENOBUFS. The n_socket parameter, if provided, will be\n populated with a value of n_clients+1 which can be used to query required\n space for the sockets buffer.  It is suggested to provide a buffer which is\n larger than max_sockets to avoid race conditions where the number of sockets\n changes between calls to this function.\n\n Note that the array of sockets should be refreshed often as once the function\n returns they may be stale.  The API is implemented in such as way as to allow\n thread-safe operations where one thread may-be using the vsl sockets to send\n messages while another is polling for a read.\n\n @memberof VSLHost"]
    pub fn vsl_host_sockets(
        host: *mut VSLHost,
        n_sockets: usize,
        sockets: *mut ::std::os::raw::c_int,
        max_sockets: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Registers the frame with the host and publishes it to subscribers."]
    pub fn vsl_host_post(
        host: *mut VSLHost,
        frame: *mut VSLFrame,
        expires: i64,
        duration: i64,
        pts: i64,
        dts: i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Creates a client and connects to the host at the provided path.  If the\n connection cannot be made NULL is returned and errno is set.\n\n @memberof VSLClient"]
    pub fn vsl_client_init(
        path: *const ::std::os::raw::c_char,
        userptr: *mut ::std::os::raw::c_void,
        reconnect: bool,
    ) -> *mut VSLClient;
}
extern "C" {
    #[doc = " Releases the client, disconnecting from the host and releasing allocated\n memory.\n\n @memberof VSLClient"]
    pub fn vsl_client_release(client: *mut VSLClient);
}
extern "C" {
    #[doc = " Disconnects from the VSLHost and stops all reconnection attempts.  This\n should be called as part of closing down a VSL client session.  It is\n thread-safe unlike vsl_client_release which disposes of the client object.\n\n @memberof VSLClient\n @since 1.1"]
    pub fn vsl_client_disconnect(client: *mut VSLClient);
}
extern "C" {
    #[doc = " Returns the optional userptr associated with this client connection.\n\n @memberof VSLClient"]
    pub fn vsl_client_userptr(client: *mut VSLClient) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Returns the path on which the client has connected to the host.\n\n @memberof VSLClient"]
    pub fn vsl_client_path(client: *const VSLClient) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Sets the socket timeout for this client.\n\n @memberof VSLClient"]
    pub fn vsl_client_set_timeout(client: *mut VSLClient, timeout: f32);
}
extern "C" {
    #[doc = " Creates and posts the video frame along with optional user pointer to any\n arbitrary data.  Typically it would be used for holding a reference to\n the host's view of the frame handle.\n\n @deprecated The vsl_frame_register function is deprecated in favour of using\n the @ref vsl_frame_init(), @ref vsl_frame_alloc() or @ref vsl_frame_attach(),\n and @ref vsl_host_post() functions which separate frame creation from posting\n to the host for publishing to subscribers.\n\n @memberof VSLFrame"]
    pub fn vsl_frame_register(
        host: *mut VSLHost,
        serial: i64,
        handle: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        fourcc: u32,
        size: usize,
        offset: usize,
        expires: i64,
        duration: i64,
        pts: i64,
        dts: i64,
        cleanup: vsl_frame_cleanup,
        userptr: *mut ::std::os::raw::c_void,
    ) -> *mut VSLFrame;
}
extern "C" {
    #[doc = " Initializes a VSLFrame without underlying frame buffer.  To create the\n backing memory either call @ref vsl_frame_alloc() or to attach to an existing\n bufer use @ref vsl_frame_attach().\n\n @since 1.3\n @memberof VSLFrame"]
    pub fn vsl_frame_init(
        width: u32,
        height: u32,
        stride: u32,
        fourcc: u32,
        userptr: *mut ::std::os::raw::c_void,
        cleanup: vsl_frame_cleanup,
    ) -> *mut VSLFrame;
}
extern "C" {
    #[doc = " Allocates the underlying memory for the frame.  This function will prefer to\n allocate using dmabuf and fallback to shared memory if dmabuf is not\n available, unless the frame has a path defined in which case shared memory is\n assumed.  If the path begins with /dev then it assumed to point to a\n dmabuf-heap device.  If path is NULL then the allocator will first attempt to\n create a dmabuf then fallback to shared memory.\n\n Allocations will be based on a buffer large enough to hold height*stride\n bytes.  If using a compressed fourcc such as JPEG the actual data will be\n smaller, this size can be captured when calling @ref vsl_frame_copy() as the\n function returns the number of bytes copied into the target frame.  There is\n currently no method to capture the actual compressed size when receiving an\n already compressed frame.  This limitation is because the size varies from\n frame to frame while the underlying buffer is of a fixed size.  When the\n actual encoded size is important, the @ref vsl_frame_copy() should be called\n directly or the reported size communicated to the client through a separate\n channel.\n\n @since 1.3\n @memberof VSLFrame"]
    pub fn vsl_frame_alloc(
        frame: *mut VSLFrame,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Frees the allocated buffer for this frame.  Does not release the frame itself\n for that use @ref vsl_frame_release().\n\n @param frame\n @since 1.3\n @memberof VSLFrame"]
    pub fn vsl_frame_unalloc(frame: *mut VSLFrame);
}
extern "C" {
    #[doc = " Attach the provided file descriptor to the VSLFrame.  If size is not provided\n it is assumed to be stride*height bytes.  If offset is provided then size\n *MUST* be provided, the offset is in bytes to the start of the frame.\n\n @since 1.3\n @memberof VSLFrame"]
    pub fn vsl_frame_attach(
        frame: *mut VSLFrame,
        fd: ::std::os::raw::c_int,
        size: usize,
        offset: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the path to the underlying VSLFrame buffer.  Note it will not always\n be available, such as when the frame was externally created.  When no path is\n available NULL is returned.\n\n @note This function is not thread-safe and you must use the string\n immediately.\n\n @since 1.3\n @memberof VSLFrame"]
    pub fn vsl_frame_path(frame: *const VSLFrame) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Unregisters the frame, removing it from the host pool.\n\n @deprecated This function is deprecated in favour of calling\n @ref vsl_frame_release() which will handle the required cleanup.\n\n @memberof VSLFrame"]
    pub fn vsl_frame_unregister(frame: *mut VSLFrame);
}
extern "C" {
    #[doc = " Copy the source frame into the target frame, with optional source crop. The\n copy handles format conversion, rescaling to fit the target frame.  Resize\n happens after the crop, if required.\n\n Copy can happen between any frames, regardless of whether they are parented\n or not or have differing parents.  The copy happens through the underlying\n buffers and will attempt to use available hardware accelerators.\n\n The function will attempt to lock target and source.  Since lock is a no-op\n when not a client frame it is safe even for free-standing frames.  Copying to\n or from a posted frame is safe but is likely to cause visual corruption such\n as tearing.\n\n @since 1.3\n @memberof VSLFrame"]
    pub fn vsl_frame_copy(
        target: *mut VSLFrame,
        source: *mut VSLFrame,
        crop: *const VSLRect,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the user pointer associated with this frame.\n\n @memberof VSLFrame"]
    pub fn vsl_frame_userptr(frame: *mut VSLFrame) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Associate userptr with this frame.\n\n @memberof VSLFrame"]
    pub fn vsl_frame_set_userptr(frame: *mut VSLFrame, userptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Waits for a frame to arrive and returns a new frame object.  Frames who's\n timestamp is less than @param until will be ignored.\n\n @memberof VSLFrame"]
    pub fn vsl_frame_wait(client: *mut VSLClient, until: i64) -> *mut VSLFrame;
}
extern "C" {
    #[doc = " Releases the frame, performing required cleanup.  If the frame was mapped it\n will be unmapped.  If the frame was posted to a host it will be removed, if\n this is a client frame it will be unlocked.\n\n @memberof VSLFrame"]
    pub fn vsl_frame_release(frame: *mut VSLFrame);
}
extern "C" {
    #[doc = " Attempts to lock the video frame.\n\n @memberof VSLFrame"]
    pub fn vsl_frame_trylock(frame: *mut VSLFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Attempts to unlock the video frame.\n\n @memberof VSLFrame"]
    pub fn vsl_frame_unlock(frame: *mut VSLFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the serial frame count of the video frame.\n\n Note this frame serial tracks the count of frames registered on the host and\n does not necessarily equal the actual frame number from the camera.\n\n @memberof VSLFrame"]
    pub fn vsl_frame_serial(frame: *const VSLFrame) -> i64;
}
extern "C" {
    #[doc = " Returns the timestamp for this frame in nanoseconds.\n\n @memberof VSLFrame"]
    pub fn vsl_frame_timestamp(frame: *const VSLFrame) -> i64;
}
extern "C" {
    #[doc = " Returns the duration for this frame in nanoseconds.\n\n @memberof VSLFrame"]
    pub fn vsl_frame_duration(frame: *const VSLFrame) -> i64;
}
extern "C" {
    #[doc = " Returns the presentation timestamp for this frame in nanoseconds.\n\n @memberof VSLFrame"]
    pub fn vsl_frame_pts(frame: *const VSLFrame) -> i64;
}
extern "C" {
    #[doc = " Returns the decode timestamp for this frame in nanoseconds.\n\n @memberof VSLFrame"]
    pub fn vsl_frame_dts(frame: *const VSLFrame) -> i64;
}
extern "C" {
    #[doc = " Returns the epiration time for this frame in milliseconds.\n\n @memberof VSLFrame"]
    pub fn vsl_frame_expires(frame: *const VSLFrame) -> i64;
}
extern "C" {
    #[doc = " Returns the FOURCC code for the video frame.\n\n @memberof VSLFrame"]
    pub fn vsl_frame_fourcc(frame: *const VSLFrame) -> u32;
}
extern "C" {
    #[doc = " Returns the width in pixels of the video frame.\n\n @memberof VSLFrame"]
    pub fn vsl_frame_width(frame: *const VSLFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the height in pixels of the video frame.\n\n @memberof VSLFrame"]
    pub fn vsl_frame_height(frame: *const VSLFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the size in bytes of the video frame.\n\n @memberof VSLFrame"]
    pub fn vsl_frame_size(frame: *const VSLFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the file descriptor for this frame or -1 if none is associated.\n\n @memberof VSLFrame"]
    pub fn vsl_frame_handle(frame: *const VSLFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the physical address of the frame.  If the frame does not support\n DMA then MMAP_FAILED is returned.\n\n @memberof VSLFrame"]
    pub fn vsl_frame_paddr(frame: *const VSLFrame) -> isize;
}
extern "C" {
    #[doc = " Maps the frame into the process' memory space, optionally also sets the\n size of the frame if @param size is non-NULL.  Ensure the frame is\n unmapped when no longer needed using @ref nn_frame_munmap().\n\n Note that a frame must be locked for the duration of the mapping.\n\n @memberof VSLFrame"]
    pub fn vsl_frame_mmap(frame: *mut VSLFrame, size: *mut usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Maps the frame into the process' memory space, optionally also sets the\n size of the frame if @param size is non-NULL.\n\n @memberof VSLFrame"]
    pub fn vsl_frame_munmap(frame: *mut VSLFrame);
}
extern "C" {
    #[doc = " Returns a fourcc integer code from the string.  If the fourcc code is invalid\n or unsupported then 0 is returned."]
    pub fn vsl_fourcc_from_string(fourcc: *const ::std::os::raw::c_char) -> u32;
}
